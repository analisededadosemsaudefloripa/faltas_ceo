---
title: "faltas_ceo_variaveis"
output: 
  #word_document:
    #reference_docx: template.docx
  html_document:
    toc: true
    toc_depth: 5
    toc_float: true
    collapsed: true
    fig_width: 9
    fig_height: 7
    code_folding: hide
---


```{r}
#Opções gerais
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	echo = T,
  options(scipen=100),
  options(digits=2)
)
options("scipen"=100, "digits"=4)#usar notação decimal
knitr::opts_chunk$set(cache=TRUE)#otimizar a utilização de memória cache
```


```{r, message=FALSE, warning=FALSE, include=FALSE}
#Importação das bibliotescas
library(readr)
library(plyr)
library(chron)#transformar caracter em hora
#library(corrgram)
library(tidyverse)
library(reshape)
library(forcats)#ordenar barras no ggplot
library(gridExtra)#arrumar multiplos gráficos em uma figura
library(knitr)
library(kableExtra)#Fazer tabela do summary
library(pander)#Fazer tabela do chi.test
library(caret)#K-fold cross validation
library(caTools)#Calcular AUC
library(gbm) #Stochastic Gradient Boosting
library(ROSE) #dealing with imbalanced data
library(klaR) #modelo naive bayes/ Localized Linear Discriminant Analysis
library(binda) #modelo Binary Discriminant Analysis
library(LiblineaR) #Support Vector Machine 
library(nnet) #Bayesian Regularized Neural Networks
library(fastAdaboost) #AdaBoost Classification Trees
library(xgboost) #eXtreme Gradient Boosting
library(deepnet) #Stacked AutoEncoder Deep Neural Network
library(MASS) #Generalized Linear Model with Stepwise Feature Selection
library(e1071) #
library(entropy) #metrica para avaliar modelos de ML
library(tibble)
library(plotly) #gráficos interativos
library(doParallel) #Parallel Processing
```


#Leitura da base de dados
```{r}
#Importanto a base
faltas_ceo <- read_csv("faltas_ceo.csv")
```

#Função para remover acentos
Esta função serve para remover os acentos.
```{r}
rm_accent <- function(str,pattern="all") {
  # Rotinas e funções úteis V 1.0
  # rm.accent - REMOVE ACENTOS DE PALAVRAS
  # Função que tira todos os acentos e pontuações de um vetor de strings.
  # Parâmetros:
  # str - vetor de strings que terão seus acentos retirados.
  # patterns - vetor de strings com um ou mais elementos indicando quais acentos deverão ser retirados.
  #            Para indicar quais acentos deverão ser retirados, um vetor com os símbolos deverão ser passados.
  #            Exemplo: pattern = c("´", "^") retirará os acentos agudos e circunflexos apenas.
  #            Outras palavras aceitas: "all" (retira todos os acentos, que são "´", "`", "^", "~", "¨", "ç")
  if(!is.character(str))
    str <- as.character(str)
  
  pattern <- unique(pattern)
  
  if(any(pattern=="Ç"))
    pattern[pattern=="Ç"] <- "ç"
  
  symbols <- c(
    acute = "áéíóúÁÉÍÓÚýÝ",
    grave = "àèìòùÀÈÌÒÙ",
    circunflex = "âêîôûÂÊÎÔÛ",
    tilde = "ãõÃÕñÑ",
    umlaut = "äëïöüÄËÏÖÜÿ",
    cedil = "çÇ"
  )
  
  nudeSymbols <- c(
    acute = "aeiouAEIOUyY",
    grave = "aeiouAEIOU",
    circunflex = "aeiouAEIOU",
    tilde = "aoAOnN",
    umlaut = "aeiouAEIOUy",
    cedil = "cC"
  )
  
  accentTypes <- c("´","`","^","~","¨","ç")
  
  if(any(c("all","al","a","todos","t","to","tod","todo")%in%pattern)) # opcao retirar todos
    return(chartr(paste(symbols, collapse=""), paste(nudeSymbols, collapse=""), str))
  
  for(i in which(accentTypes%in%pattern))
    str <- chartr(symbols[i],nudeSymbols[i], str)
  
  return(str)
}

```



#Tratamento e pré-processamento das váriaveis
As variáveis UNIDADE_ATD, ESPECIALIDADE, DIA_SEMANA, SEXO, UNIDADE_REFERENCIA, RETORNO, FALTA foram transformadas para fator;
As variáveis DIA_SEMANA e ESCOLARIDADE também foram tranformadas para fator, porém com novos níveis (valores);
A variável CNS foi transformada em character;
As variáveis DATA_ATD e DN foram formatadas para DD/MM/AAAA, e logo após foi subtraido data de nascimento (DN) de data de atendimento (DATA_ATD) para dividir por 365 para criar a variável IDADE (transformada em Double);
A variável PERIODO_ATD foi gerada dividindo HORA_ATD em dois periodos (manhã e tarde) e também transformada em fatos;
Foram removidas do banco as variáveis que não seriam usadas na análise.
```{r, include=FALSE}
#Transformando as variáveis
faltas_ceo$UNIDADE_ATD <- as.factor(faltas_ceo$UNIDADE_ATD)
faltas_ceo$ESPECIALIDADE <- as.factor(faltas_ceo$ESPECIALIDADE)
faltas_ceo$DIA_SEMANA <- factor(faltas_ceo$DIA_SEMANA, levels = c("SEG", "TER", "QUA", "QUI", "SEX", "SÁB"))
faltas_ceo$COD_USUARIO <- as.character(faltas_ceo$COD_USUARIO)
faltas_ceo$CNS<- as.character(faltas_ceo$CNS)
faltas_ceo$SEXO <- as.factor(faltas_ceo$SEXO)
faltas_ceo$UNIDADE_REFERENCIA <- as.factor(faltas_ceo$UNIDADE_REFERENCIA)
faltas_ceo$ESCOLARIDADE <- factor(faltas_ceo$ESCOLARIDADE, levels = c("Não sabe ler / escrever",
                                        "Alfabetizado", "Fundamental incompleto (1° grau)",
                                        "Fundamental completo (1° grau)", "Médio incompleto (2° grau)",
                                        "Médio completo (2° grau)", "Superior incompleto", "Superior completo",
                                        "Especialização/Residencia", "Mestrado", "Doutorado"))
unique(faltas_ceo$ESCOLARIDADE)
faltas_ceo$RETORNO <- as.factor(faltas_ceo$RETORNO)
faltas_ceo$FALTA <- as.factor(faltas_ceo$FALTA)
faltas_ceo$DATA_ATD <- as.Date(faltas_ceo$DATA_ATD, format = "%d/%m/%Y")
faltas_ceo$DN <- as.Date(faltas_ceo$DN, format = "%d/%m/%Y")
faltas_ceo$IDADE <- as.double((faltas_ceo$DATA_ATD - faltas_ceo$DN)/365) 
faltas_ceo$HORA_ATD <- chron(times = faltas_ceo$HORA_ATD)
faltas_ceo$PERIODO_ATD <- ifelse(faltas_ceo$HORA_ATD < chron(times = "12:00:00"), "manhã", "tarde")
faltas_ceo$PERIODO_ATD <- as.factor(faltas_ceo$PERIODO_ATD)

#Retirando as variáveis que não serão utilizadas
faltas_ceo <-faltas_ceo[,-c(3,4,5,6,7,9,11,12,13)]
```

#Removendo acentos
Aplicando a função para remover os acentos das variáveis desejadas.
Algumas das variáveis voltaram a ser do tipo caracter, portanto foi necessário transformar em fatores novamente.
```{r}
#Aplicando a função
faltas_ceo$UNIDADE_REFERENCIA <- rm_accent(faltas_ceo$UNIDADE_REFERENCIA)
faltas_ceo$ESCOLARIDADE <- rm_accent(faltas_ceo$ESCOLARIDADE)
faltas_ceo$PERIODO_ATD <- rm_accent(faltas_ceo$PERIODO_ATD)

#transformação para fator
faltas_ceo$PERIODO_ATD <- as.factor(faltas_ceo$PERIODO_ATD)
faltas_ceo$UNIDADE_REFERENCIA <- as.factor(faltas_ceo$UNIDADE_REFERENCIA)
faltas_ceo$ESCOLARIDADE <- as.factor(faltas_ceo$ESCOLARIDADE)
```


#Percentual de faltas por especialidade de 2014 até 2017
Gráficos do percentual de faltas por especialidade de 2014 até 2017.
Para calcular, é adicionada uma coluna preenchida com valores 1, que serve para ajudar a agregar as faltas e não faltas, e somar a contagem por especialidade. Depois foi feito o calculo da percentual de faltantes por especialidade, (FALTAS / (FALTAS + NÃO FALTAS)) * 100. E por fim, o resultado gerando um gráfico de radar.
```{r}
faltas_ceo_agg <- faltas_ceo[, c(2,9)] 
faltas_ceo_agg['VALOR'] <- 1
faltas_ceo_agg$VALOR <- as.numeric(faltas_ceo_agg$VALOR)

faltas_ceo_agg <- aggregate(faltas_ceo_agg$VALOR, by=list(faltas_ceo_agg$ESPECIALIDADE, faltas_ceo_agg$FALTA), FUN = sum)

names(faltas_ceo_agg)<- c("ESPECIALIDADE", "FALTA", "VALOR")

faltas_ceo_agg <- reshape(faltas_ceo_agg, idvar = "ESPECIALIDADE", timevar = "FALTA", direction = "wide")

faltas_ceo_agg['VALOR_P'] <- (faltas_ceo_agg$VALOR.S / (faltas_ceo_agg$VALOR.S + faltas_ceo_agg$VALOR.N)) * 100

faltas_ceo_agg <- faltas_ceo_agg[, c(1,4)] 

faltas_ceo_agg$ESPECIALIDADE <- factor(faltas_ceo_agg$ESPECIALIDADE, levels = faltas_ceo_agg$ESPECIALIDADE[order(faltas_ceo_agg$VALOR_P)])

plot_g <- ggplot(faltas_ceo_agg, aes(x=ESPECIALIDADE, y=VALOR_P)) +
  ggtitle("Percentual de faltas por especialidade (2014 e 2017)") +
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  coord_flip()

ggplotly(plot_g)

spiderplot_total <- faltas_ceo_agg
spiderplot_total['Total'] <- c(100)
especialidades_total <- spiderplot_total$ESPECIALIDADE
especialidades_total %>% as.list()

p <- plot_ly(
    type = 'scatterpolar',
    r = c(spiderplot_total$VALOR_P),
    theta = especialidades_total[1:9],
    fill = 'toself'
  ) %>%
  layout(
    title = "Percentual de faltas por especialidade (2014 e 2017)",
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0, 100)
      )
    ),
    showlegend = F
  )
#p
```

```{r}
summary(spiderplot_total)

```


#Separando o banco
Foram removidas da coluna DATA_ATD (dd/mm/aaaa) o dia e o mes, sobrando apenas (aaaa), com o propósito de cortar o banco apenas para os anos de 2016 e 2017;
E depois separados em nove novos bancos, ou seja, um banco para cada especialidade.
É aplicada a função na.omit() nos três bancos que serão usados na análise.
```{r}
#Cortando o banco para deixar apenas os anos de 2016 e 2017
#Separando o banco por especialidade
faltas_ceo$DATA_ATD <- str_sub(faltas_ceo$DATA_ATD, end=4)

faltas_ceo_16_17 <- subset(faltas_ceo, faltas_ceo$DATA_ATD==2016 | faltas_ceo$DATA_ATD==2017)

Odonto_Endodontia <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Endodontia")
Odonto_Endodontia <- na.omit(Odonto_Endodontia)
Odonto_Cir_BucoMaxilo <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Cir.Buco Maxilo")
Odonto_ProteseDentaria <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Prótese Dentária")
Odonto_Perio <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Perio")
Odonto_Perio <- na.omit(Odonto_Perio)
Odontologia <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odontologia")
OdontoEspec_CEO <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto Espec/CEO")
Odonto_Radiologica <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Radiológica")
Odonto_Pediatria <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Pediatria")
Odonto_EstomatologiaBucal <- subset(faltas_ceo_16_17, faltas_ceo_16_17$ESPECIALIDADE=="Odonto/Estomatologia Bucal")
Odonto_EstomatologiaBucal <- na.omit(Odonto_EstomatologiaBucal)

#lista <- unique(faltas_ceo_16_17$ESPECIALIDADE)
#lista <- lista %>% as.data.frame()
```



#Falta por especialidade
Foi feita uma análise para identificar o maior precentual de faltas por especialidade nos anos de 2016 e 2017.
As únicas variáveis necessárias foram ESPECIALIDADE e FALTAS, porém foi preciso criar uma coluna VALOR, para que fosse possível agregar os valores de falta por especialidade, o resultado foi transformado em duas novas colunas com os valores de FALTA.S e FALTA.N, o percentual foi calculado, (FALTA.S / (FALTA.S + FALTA.N) * 100) e atribuido a uma nova coluna, gerando também um gráfico ordenado pelo maior valor. A partir disso, foi decidido usar os bancos das três primeiras especialidades com maior percentual de faltas, que são: Odonto_EstomatologiaBucal, Odonto_Radiologica, Odonto_Perio, para aplicar os algoritmos de machine learning, porém o banco da EstomatologiaBucal tem uma quantidade de dados pequena (850 linhas), e por conta disso não possui muita variância entre os dados de algumas variáveis, o que acabou gerando erros nos testes com os algoritmos, e portanto foi substituido pelo quarto banco na sequência, Odonto_Endodontia.
```{r}
faltas_ceo_16_17_agg <- faltas_ceo_16_17[, c(2,9)] 
faltas_ceo_16_17_agg['VALOR'] <- 1
faltas_ceo_16_17_agg$VALOR <- as.numeric(faltas_ceo_16_17_agg$VALOR)

faltas_ceo_16_17_agg <- aggregate(faltas_ceo_16_17_agg$VALOR, by=list(faltas_ceo_16_17_agg$ESPECIALIDADE, faltas_ceo_16_17_agg$FALTA), FUN = sum)

names(faltas_ceo_16_17_agg)<- c("ESPECIALIDADE", "FALTA", "VALOR")

faltas_ceo_16_17_agg <- reshape(faltas_ceo_16_17_agg, idvar = "ESPECIALIDADE", timevar = "FALTA", direction = "wide")

faltas_ceo_16_17_agg['VALOR_P'] <- (faltas_ceo_16_17_agg$VALOR.S / (faltas_ceo_16_17_agg$VALOR.S + faltas_ceo_16_17_agg$VALOR.N)) * 100

faltas_ceo_16_17_agg <- faltas_ceo_16_17_agg[, c(1,4)] 

faltas_ceo_16_17_agg$ESPECIALIDADE <- factor(faltas_ceo_16_17_agg$ESPECIALIDADE, levels = faltas_ceo_16_17_agg$ESPECIALIDADE[order(faltas_ceo_16_17_agg$VALOR_P)])

plot_g <- ggplot(faltas_ceo_16_17_agg, aes(x=ESPECIALIDADE, y=VALOR_P)) +
  ggtitle("Percentual de faltas por especialidade (2016 e 2017)") +
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  coord_flip()

ggplotly(plot_g)

spiderplot <- faltas_ceo_16_17_agg
spiderplot['Total'] <- c(100)
especialidades <- spiderplot$ESPECIALIDADE
especialidades %>% as.list()

p <- plot_ly(
    type = 'scatterpolar',
    r = c(spiderplot$VALOR_P),
    theta = especialidades[1:9],
    fill = 'toself'
  ) %>%
  layout(
    title = "Percentual de faltas por especialidade (2016 e 2017)",
    polar = list(
      radialaxis = list(
        visible = T,
        range = c(0, 100)
      )
    ),
    showlegend = F
  )
#p

```


#Descrição dos dados
Descrição dos dados (summary e plot) para os bancos escolhidos. Os dados dos plots estão em percentual.
As variáveis foram separadas para cada um dos bancos.

Descrição de variáveis:
DIA_SEMANA
```{r}
#########################################################################################################################
#Odonto_Endodontia por dia da semana

dia_semana_Odonto_Endodontia <- summary(Odonto_Endodontia$DIA_SEMANA)
dia_semana_Odonto_Endodontia <- as.data.frame(dia_semana_Odonto_Endodontia)
dia_semana_Odonto_Endodontia

Odonto_Endodontia_dia <- Odonto_Endodontia[, c('DIA_SEMANA','FALTA')] 
Odonto_Endodontia_dia['VALOR'] <- 1
Odonto_Endodontia_dia$VALOR <- as.numeric(Odonto_Endodontia_dia$VALOR)

Odonto_Endodontia_dia <- aggregate(Odonto_Endodontia_dia$VALOR, by=list(Odonto_Endodontia_dia$DIA_SEMANA, Odonto_Endodontia_dia$FALTA), FUN = sum)

names(Odonto_Endodontia_dia)<- c("DIA_ATD", "FALTA", "VALOR")

Odonto_Endodontia_dia <- reshape(Odonto_Endodontia_dia, idvar = "DIA_ATD", timevar = "FALTA", direction = "wide")


Odonto_Endodontia_dia['VALOR_P'] <- (Odonto_Endodontia_dia$VALOR.S / (Odonto_Endodontia_dia$VALOR.S + Odonto_Endodontia_dia$VALOR.N)) * 100


Odonto_Endodontia_dia <- Odonto_Endodontia_dia[, c(1,4)] 

Odonto_Endodontia_dia$DIA_ATD <- factor(Odonto_Endodontia_dia$DIA_ATD, levels = Odonto_Endodontia_dia$DIA_ATD[order(Odonto_Endodontia_dia$VALOR_P)])

ggplot(Odonto_Endodontia_dia, aes(x=DIA_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por dia da semana Odonto Endodontia em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Radiologica por dia da semana

dia_semana_Odonto_Radiologica <- summary(Odonto_Radiologica$DIA_SEMANA)
dia_semana_Odonto_Radiologica <- as.data.frame(dia_semana_Odonto_Radiologica)
dia_semana_Odonto_Radiologica

Odonto_Radiologica_dia <- Odonto_Radiologica[, c('DIA_SEMANA','FALTA')] 
Odonto_Radiologica_dia['VALOR'] <- 1
Odonto_Radiologica_dia$VALOR <- as.numeric(Odonto_Radiologica_dia$VALOR)

Odonto_Radiologica_dia <- aggregate(Odonto_Radiologica_dia$VALOR, by=list(Odonto_Radiologica_dia$DIA_SEMANA, Odonto_Radiologica_dia$FALTA), FUN = sum)

names(Odonto_Radiologica_dia)<- c("DIA_ATD", "FALTA", "VALOR")

Odonto_Radiologica_dia <- reshape(Odonto_Radiologica_dia, idvar = "DIA_ATD", timevar = "FALTA", direction = "wide")


Odonto_Radiologica_dia['VALOR_P'] <- (Odonto_Radiologica_dia$VALOR.S / (Odonto_Radiologica_dia$VALOR.S + Odonto_Radiologica_dia$VALOR.N)) * 100


Odonto_Radiologica_dia <- Odonto_Radiologica_dia[, c(1,4)] 

Odonto_Radiologica_dia$DIA_ATD <- factor(Odonto_Radiologica_dia$DIA_ATD, levels = Odonto_Radiologica_dia$DIA_ATD[order(Odonto_Radiologica_dia$VALOR_P)])

ggplot(Odonto_Radiologica_dia, aes(x=DIA_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por dia da semana Odonto Radiologica em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Perio por dia da semana

dia_semana_Odonto_Perio <- summary(Odonto_Perio$DIA_SEMANA)
dia_semana_Odonto_Perio <- as.data.frame(dia_semana_Odonto_Perio)
dia_semana_Odonto_Perio

Odonto_Perio_dia <- Odonto_Perio[, c('DIA_SEMANA','FALTA')] 
Odonto_Perio_dia['VALOR'] <- 1
Odonto_Perio_dia$VALOR <- as.numeric(Odonto_Perio_dia$VALOR)

Odonto_Perio_dia <- aggregate(Odonto_Perio_dia$VALOR, by=list(Odonto_Perio_dia$DIA_SEMANA, Odonto_Perio_dia$FALTA), FUN = sum)

names(Odonto_Perio_dia)<- c("DIA_ATD", "FALTA", "VALOR")

Odonto_Perio_dia <- reshape(Odonto_Perio_dia, idvar = "DIA_ATD", timevar = "FALTA", direction = "wide")


Odonto_Perio_dia['VALOR_P'] <- (Odonto_Perio_dia$VALOR.S / (Odonto_Perio_dia$VALOR.S + Odonto_Perio_dia$VALOR.N)) * 100


Odonto_Perio_dia <- Odonto_Perio_dia[, c(1,4)] 

Odonto_Perio_dia$DIA_ATD <- factor(Odonto_Perio_dia$DIA_ATD, levels = Odonto_Perio_dia$DIA_ATD[order(Odonto_Perio_dia$VALOR_P)])

ggplot(Odonto_Perio_dia, aes(x=DIA_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por dia da semana Odonto Perio em %") +
  coord_flip()

```


SEXO
```{r}
#########################################################################################################################
#Odonto_Endodontia por dia da semana

sexo_Odonto_Endodontia <- summary(Odonto_Endodontia$SEXO)
sexo_Odonto_Endodontia <- as.data.frame(sexo_Odonto_Endodontia)
sexo_Odonto_Endodontia

Odonto_Endodontia_dia <- Odonto_Endodontia[, c('SEXO','FALTA')] 
Odonto_Endodontia_dia['VALOR'] <- 1
Odonto_Endodontia_dia$VALOR <- as.numeric(Odonto_Endodontia_dia$VALOR)

Odonto_Endodontia_dia <- aggregate(Odonto_Endodontia_dia$VALOR, by=list(Odonto_Endodontia_dia$SEXO, Odonto_Endodontia_dia$FALTA), FUN = sum)

names(Odonto_Endodontia_dia)<- c("SEXO", "FALTA", "VALOR")

Odonto_Endodontia_dia <- reshape(Odonto_Endodontia_dia, idvar = "SEXO", timevar = "FALTA", direction = "wide")


Odonto_Endodontia_dia['VALOR_P'] <- (Odonto_Endodontia_dia$VALOR.S / (Odonto_Endodontia_dia$VALOR.S + Odonto_Endodontia_dia$VALOR.N)) * 100


Odonto_Endodontia_dia <- Odonto_Endodontia_dia[, c(1,4)] 

Odonto_Endodontia_dia$SEXO <- factor(Odonto_Endodontia_dia$SEXO, levels = Odonto_Endodontia_dia$SEXO[order(Odonto_Endodontia_dia$VALOR_P)])

ggplot(Odonto_Endodontia_dia, aes(x=SEXO, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por sexo Odonto Endodontia em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Radiologica por dia da semana

sexo_Odonto_Radiologica <- summary(Odonto_Radiologica$SEXO)
sexo_Odonto_Radiologica <- as.data.frame(sexo_Odonto_Radiologica)
sexo_Odonto_Radiologica

Odonto_Radiologica_dia <- Odonto_Radiologica[, c('SEXO','FALTA')] 
Odonto_Radiologica_dia['VALOR'] <- 1
Odonto_Radiologica_dia$VALOR <- as.numeric(Odonto_Radiologica_dia$VALOR)

Odonto_Radiologica_dia <- aggregate(Odonto_Radiologica_dia$VALOR, by=list(Odonto_Radiologica_dia$SEXO, Odonto_Radiologica_dia$FALTA), FUN = sum)

names(Odonto_Radiologica_dia)<- c("SEXO", "FALTA", "VALOR")

Odonto_Radiologica_dia <- reshape(Odonto_Radiologica_dia, idvar = "SEXO", timevar = "FALTA", direction = "wide")


Odonto_Radiologica_dia['VALOR_P'] <- (Odonto_Radiologica_dia$VALOR.S / (Odonto_Radiologica_dia$VALOR.S + Odonto_Radiologica_dia$VALOR.N)) * 100


Odonto_Radiologica_dia <- Odonto_Radiologica_dia[, c(1,4)] 

Odonto_Radiologica_dia$SEXO <- factor(Odonto_Radiologica_dia$SEXO, levels = Odonto_Radiologica_dia$SEXO[order(Odonto_Radiologica_dia$VALOR_P)])

ggplot(Odonto_Radiologica_dia, aes(x=SEXO, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por sexo Odonto Radiologica em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Perio por dia da semana

sexo_Odonto_Perio <- summary(Odonto_Perio$SEXO)
sexo_Odonto_Perio <- as.data.frame(sexo_Odonto_Perio)
sexo_Odonto_Perio

Odonto_Perio_dia <- Odonto_Perio[, c('SEXO','FALTA')] 
Odonto_Perio_dia['VALOR'] <- 1
Odonto_Perio_dia$VALOR <- as.numeric(Odonto_Perio_dia$VALOR)

Odonto_Perio_dia <- aggregate(Odonto_Perio_dia$VALOR, by=list(Odonto_Perio_dia$SEXO, Odonto_Perio_dia$FALTA), FUN = sum)

names(Odonto_Perio_dia)<- c("SEXO", "FALTA", "VALOR")

Odonto_Perio_dia <- reshape(Odonto_Perio_dia, idvar = "SEXO", timevar = "FALTA", direction = "wide")


Odonto_Perio_dia['VALOR_P'] <- (Odonto_Perio_dia$VALOR.S / (Odonto_Perio_dia$VALOR.S + Odonto_Perio_dia$VALOR.N)) * 100


Odonto_Perio_dia <- Odonto_Perio_dia[, c(1,4)] 

Odonto_Perio_dia$SEXO <- factor(Odonto_Perio_dia$SEXO, levels = Odonto_Perio_dia$SEXO[order(Odonto_Perio_dia$VALOR_P)])

ggplot(Odonto_Perio_dia, aes(x=SEXO, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por sexo Odonto Perio em %") +
  coord_flip()

```


ESCOLARIDADE
```{r}
#########################################################################################################################
#Odonto_Endodontia por dia da semana

escolaridade_Odonto_Endodontia <- summary(Odonto_Endodontia$ESCOLARIDADE)
escolaridade_Odonto_Endodontia <- as.data.frame(escolaridade_Odonto_Endodontia)
escolaridade_Odonto_Endodontia

Odonto_Endodontia_escolaridade <- Odonto_Endodontia[, c('ESCOLARIDADE','FALTA')] 
Odonto_Endodontia_escolaridade['VALOR'] <- 1
Odonto_Endodontia_escolaridade$VALOR <- as.numeric(Odonto_Endodontia_escolaridade$VALOR)

Odonto_Endodontia_escolaridade <- aggregate(Odonto_Endodontia_escolaridade$VALOR, by=list(Odonto_Endodontia_escolaridade$ESCOLARIDADE, Odonto_Endodontia_escolaridade$FALTA), FUN = sum)

names(Odonto_Endodontia_escolaridade)<- c("ESCOLARIDADE", "FALTA", "VALOR")

Odonto_Endodontia_escolaridade <- reshape(Odonto_Endodontia_escolaridade, idvar = "ESCOLARIDADE", timevar = "FALTA", direction = "wide")


Odonto_Endodontia_escolaridade['VALOR_P'] <- (Odonto_Endodontia_escolaridade$VALOR.S / (Odonto_Endodontia_escolaridade$VALOR.S + Odonto_Endodontia_escolaridade$VALOR.N)) * 100


Odonto_Endodontia_escolaridade <- Odonto_Endodontia_escolaridade[, c(1,4)] 

Odonto_Endodontia_escolaridade$ESCOLARIDADE <- factor(Odonto_Endodontia_escolaridade$ESCOLARIDADE, levels = Odonto_Endodontia_escolaridade$ESCOLARIDADE[order(Odonto_Endodontia_escolaridade$VALOR_P)])

ggplot(Odonto_Endodontia_escolaridade, aes(x=ESCOLARIDADE, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por escolaridade Odonto Endodontia em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Radiologica por dia da semana

escolaridade_Odonto_Radiologica <- summary(Odonto_Radiologica$ESCOLARIDADE)
escolaridade_Odonto_Radiologica <- as.data.frame(escolaridade_Odonto_Radiologica)
escolaridade_Odonto_Radiologica

Odonto_Radiologica_escolaridade <- Odonto_Radiologica[, c('ESCOLARIDADE','FALTA')] 
Odonto_Radiologica_escolaridade['VALOR'] <- 1
Odonto_Radiologica_escolaridade$VALOR <- as.numeric(Odonto_Radiologica_escolaridade$VALOR)

Odonto_Radiologica_escolaridade <- aggregate(Odonto_Radiologica_escolaridade$VALOR, by=list(Odonto_Radiologica_escolaridade$ESCOLARIDADE, Odonto_Radiologica_escolaridade$FALTA), FUN = sum)

names(Odonto_Radiologica_escolaridade)<- c("ESCOLARIDADE", "FALTA", "VALOR")

Odonto_Radiologica_escolaridade <- reshape(Odonto_Radiologica_escolaridade, idvar = "ESCOLARIDADE", timevar = "FALTA", direction = "wide")


Odonto_Radiologica_escolaridade['VALOR_P'] <- (Odonto_Radiologica_escolaridade$VALOR.S / (Odonto_Radiologica_escolaridade$VALOR.S + Odonto_Radiologica_escolaridade$VALOR.N)) * 100


Odonto_Radiologica_escolaridade <- Odonto_Radiologica_escolaridade[, c(1,4)] 

Odonto_Radiologica_escolaridade$ESCOLARIDADE <- factor(Odonto_Radiologica_escolaridade$ESCOLARIDADE, levels = Odonto_Radiologica_escolaridade$ESCOLARIDADE[order(Odonto_Radiologica_escolaridade$VALOR_P)])

ggplot(Odonto_Radiologica_escolaridade, aes(x=ESCOLARIDADE, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por escolaridade Odonto Radiologica em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Perio por dia da semana

escolaridade_Odonto_Perio <- summary(Odonto_Perio$ESCOLARIDADE)
escolaridade_Odonto_Perio <- as.data.frame(escolaridade_Odonto_Perio)
escolaridade_Odonto_Perio

Odonto_Perio_escolaridade <- Odonto_Perio[, c('ESCOLARIDADE','FALTA')] 
Odonto_Perio_escolaridade['VALOR'] <- 1
Odonto_Perio_escolaridade$VALOR <- as.numeric(Odonto_Perio_escolaridade$VALOR)

Odonto_Perio_escolaridade <- aggregate(Odonto_Perio_escolaridade$VALOR, by=list(Odonto_Perio_escolaridade$ESCOLARIDADE, Odonto_Perio_escolaridade$FALTA), FUN = sum)

names(Odonto_Perio_escolaridade)<- c("ESCOLARIDADE", "FALTA", "VALOR")

Odonto_Perio_escolaridade <- reshape(Odonto_Perio_escolaridade, idvar = "ESCOLARIDADE", timevar = "FALTA", direction = "wide")


Odonto_Perio_escolaridade['VALOR_P'] <- (Odonto_Perio_escolaridade$VALOR.S / (Odonto_Perio_escolaridade$VALOR.S + Odonto_Perio_escolaridade$VALOR.N)) * 100


Odonto_Perio_escolaridade <- Odonto_Perio_escolaridade[, c(1,4)] 

Odonto_Perio_escolaridade$ESCOLARIDADE <- factor(Odonto_Perio_escolaridade$ESCOLARIDADE, levels = Odonto_Perio_escolaridade$ESCOLARIDADE[order(Odonto_Perio_escolaridade$VALOR_P)])

ggplot(Odonto_Perio_escolaridade, aes(x=ESCOLARIDADE, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por escolaridade Odonto Perio em %") +
  coord_flip()
```


PERIODO_ATD
```{r}
#########################################################################################################################
#Odonto_Endodontia por dia da semana

periodo_atd_Odonto_Endodontia <- summary(Odonto_Endodontia$PERIODO_ATD)
periodo_atd_Odonto_Endodontia <- as.data.frame(periodo_atd_Odonto_Endodontia)
periodo_atd_Odonto_Endodontia

Odonto_Endodontia_periodo <- Odonto_Endodontia[, c('PERIODO_ATD','FALTA')] 
Odonto_Endodontia_periodo['VALOR'] <- 1
Odonto_Endodontia_periodo$VALOR <- as.numeric(Odonto_Endodontia_periodo$VALOR)

Odonto_Endodontia_periodo <- aggregate(Odonto_Endodontia_periodo$VALOR, by=list(Odonto_Endodontia_periodo$PERIODO_ATD, Odonto_Endodontia_periodo$FALTA), FUN = sum)

names(Odonto_Endodontia_periodo)<- c("PERIODO_ATD", "FALTA", "VALOR")

Odonto_Endodontia_periodo <- reshape(Odonto_Endodontia_periodo, idvar = "PERIODO_ATD", timevar = "FALTA", direction = "wide")


Odonto_Endodontia_periodo['VALOR_P'] <- (Odonto_Endodontia_periodo$VALOR.S / (Odonto_Endodontia_periodo$VALOR.S + Odonto_Endodontia_periodo$VALOR.N)) * 100


Odonto_Endodontia_periodo <- Odonto_Endodontia_periodo[, c(1,4)] 

Odonto_Endodontia_periodo$PERIODO_ATD <- factor(Odonto_Endodontia_periodo$PERIODO_ATD, levels = Odonto_Endodontia_periodo$PERIODO_ATD[order(Odonto_Endodontia_periodo$VALOR_P)])

ggplot(Odonto_Endodontia_periodo, aes(x=PERIODO_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por periodo de atendimento Odonto Endodontia em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Radiologica por dia da semana

periodo_atd_Odonto_Radiologica <- summary(Odonto_Radiologica$PERIODO_ATD)
periodo_atd_Odonto_Radiologica <- as.data.frame(periodo_atd_Odonto_Radiologica)
periodo_atd_Odonto_Radiologica

Odonto_Radiologica_periodo <- Odonto_Radiologica[, c('PERIODO_ATD','FALTA')] 
Odonto_Radiologica_periodo['VALOR'] <- 1
Odonto_Radiologica_periodo$VALOR <- as.numeric(Odonto_Radiologica_periodo$VALOR)

Odonto_Radiologica_periodo <- aggregate(Odonto_Radiologica_periodo$VALOR, by=list(Odonto_Radiologica_periodo$PERIODO_ATD, Odonto_Radiologica_periodo$FALTA), FUN = sum)

names(Odonto_Radiologica_periodo)<- c("PERIODO_ATD", "FALTA", "VALOR")

Odonto_Radiologica_periodo <- reshape(Odonto_Radiologica_periodo, idvar = "PERIODO_ATD", timevar = "FALTA", direction = "wide")


Odonto_Radiologica_periodo['VALOR_P'] <- (Odonto_Radiologica_periodo$VALOR.S / (Odonto_Radiologica_periodo$VALOR.S + Odonto_Radiologica_periodo$VALOR.N)) * 100


Odonto_Radiologica_periodo <- Odonto_Radiologica_periodo[, c(1,4)] 

Odonto_Radiologica_periodo$PERIODO_ATD <- factor(Odonto_Radiologica_periodo$PERIODO_ATD, levels = Odonto_Radiologica_periodo$PERIODO_ATD[order(Odonto_Radiologica_periodo$VALOR_P)])

ggplot(Odonto_Radiologica_periodo, aes(x=PERIODO_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por periodo de atendimento Odonto Radiologica em %") +
  coord_flip()


#########################################################################################################################
#Odonto_Perio por dia da semana

periodo_atd_Odonto_Perio <- summary(Odonto_Perio$PERIODO_ATD)
periodo_atd_Odonto_Perio <- as.data.frame(periodo_atd_Odonto_Perio)
periodo_atd_Odonto_Perio

Odonto_Perio_periodo <- Odonto_Perio[, c('PERIODO_ATD','FALTA')] 
Odonto_Perio_periodo['VALOR'] <- 1
Odonto_Perio_periodo$VALOR <- as.numeric(Odonto_Perio_periodo$VALOR)

Odonto_Perio_periodo <- aggregate(Odonto_Perio_periodo$VALOR, by=list(Odonto_Perio_periodo$PERIODO_ATD, Odonto_Perio_periodo$FALTA), FUN = sum)

names(Odonto_Perio_periodo)<- c("PERIODO_ATD", "FALTA", "VALOR")

Odonto_Perio_periodo <- reshape(Odonto_Perio_periodo, idvar = "PERIODO_ATD", timevar = "FALTA", direction = "wide")


Odonto_Perio_periodo['VALOR_P'] <- (Odonto_Perio_periodo$VALOR.S / (Odonto_Perio_periodo$VALOR.S + Odonto_Perio_periodo$VALOR.N)) * 100


Odonto_Perio_periodo <- Odonto_Perio_periodo[, c(1,4)] 

Odonto_Perio_periodo$PERIODO_ATD <- factor(Odonto_Perio_periodo$PERIODO_ATD, levels = Odonto_Perio_periodo$PERIODO_ATD[order(Odonto_Perio_periodo$VALOR_P)])

ggplot(Odonto_Perio_periodo, aes(x=PERIODO_ATD, y=VALOR_P)) +   
  geom_bar(aes(fill = VALOR_P), stat="identity") +
  scale_fill_gradient(low = 'green', high = 'red') +
  ggtitle("Faltas por periodo de atendimento Odonto Perio em %") +
  coord_flip()
```


#Função para aplicar os modelos de machine learning
Foi criada uma função que recebe como parametro o nome de um banco e aplica vários modelos de machine learning para retornar o que apresentar melhor resultado.
Para aplicar os modelos é preciso separar o banco em treino (75% da amostra) e teste (25% da amostra), também é necessário criar um "controle", que inclui método (repeated cross-validation), number (número de folds), repeats (número de iterações para cada fold), sampling (para balancear os dados). O número de folds usado foi 10, com 5 repetições.
Foram escolhidos oito modelos de machine learning, que são: "glm" = Generalized Linear Model, "ranger" = Random Forest, "knn" = k-Nearest Neighbors, "nnet" = Neural Network, "dnn" = Stacked AutoEncoder Deep Neural Network, "xgbTree" = eXtreme Gradient Boosting, "gbm" = Stochastic Gradient Boosting, "adaboost" = AdaBoost Classification Trees.
Os modelos são colocados em uma lista e com um método WHILE, a função executa todos os modelos da mesma. No final de cada execução é preciso verificar se o modelo é realmente útil para o propósito de classificação, para isso foi escolhido o valor preditivo negativo como instrumento de avaliação. A função retorna a matriz de confusão para a predição do melhor modelo.
```{r}
ml_models <- function(nome_banco){
  
  ##################################################################################
  #Para fazer o desenho da matriz de confusão
  draw_confusion_matrix <- function(cm) {

  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)

  # create the matrix 
  rect(150, 430, 240, 370, col='red')
  text(195, 435, 'Não', cex=1.2)
  rect(250, 430, 340, 370, col='green')
  text(295, 435, 'Sim', cex=1.2)
  text(125, 370, 'Predição', cex=1.3, srt=90, font=2)
  text(245, 450, 'Referência', cex=1.3, font=2)
  rect(150, 305, 240, 365, col='green')
  rect(250, 305, 340, 365, col='red')
  text(140, 400, 'Não', cex=1.2, srt=90)
  text(140, 335, 'Sim', cex=1.2, srt=90)

  # add in the cm results 
  res <- as.numeric(cm$table)
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')

  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETALHES", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)

  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
  }  
  ##################################################################################
  
  set.seed(2)
  #removendo os valores NA do banco
  banco_escolhido <- na.omit(nome_banco)

  ## Criando a amostra de treino com 75% do tamanho da amostra total e amostra de teste com 25%
  smp_size <- floor(0.75 * nrow(banco_escolhido))
  
  train_ind <- sample(seq_len(nrow(banco_escolhido)), size = smp_size)
  
  train <- banco_escolhido[train_ind, ]
  test <- banco_escolhido[-train_ind, ]
  #são criadas três variáveis que recebem os bancos de train_prep (treino), test_prep (sem a coluna da variável de desfecho, para aplicar   o modelo e classificar) e test_control (com a coluna da variável de desfecho, para comparar com a predição.) 
  train_prep <- train
  test_prep <- test[, -c(9)]
  test_control <- test
  
  table(train_prep$FALTA)
  
  #verifica a variancia das variáveis e remove caso seja 0 ou próximo de 0
  nzv_cols <- nearZeroVar(train_prep)
  if(length(nzv_cols) > 0) train_prep <- train_prep[, -nzv_cols]
  
  
  #Create train/test index
  # Create trainControl object: myControl - Deve ser utilizado em todos os modelos para que sejam comparáveis
  myControl <- trainControl(
    method = "repeatedcv", #"repeatedcv" é o método para realizar as repetições
    number = 10, #number é o número de folds
    repeats = 5, #repeats é o número de repetições para cada fold
    summaryFunction = twoClassSummary,
    classProbs = TRUE, # IMPORTANT!
    verboseIter = FALSE,
    savePredictions = TRUE,
    returnResamp = "all",
    sampling = "smote" #balanceamento dos dados
    
  )
  
  
  
  #lista de modelos que serão usados inicialmente 
  # "glm" = Generalized Linear Model, "ranger" = Random Forest, "knn" = k-Nearest Neighbors, 
  #"nnet" = Neural Network, "dnn" = Stacked AutoEncoder Deep Neural Network, 
  #"xgbTree" = eXtreme Gradient Boosting, "gbm" = Stochastic Gradient Boosting, "adaboost" = AdaBoost Classification Trees.
  
  # "glm", "ranger", "knn", "gbm", "nnet", "adaboost", "xgbTree", "dnn"
  modelos = c("glm", "ranger", "knn", "gbm", "nnet", "adaboost", "xgbTree", "dnn")
  
  i <- 1 #indice para atualizar o while
  index <- 1 #indice que retorna o modelo da lista
  maior_valor <- 0 #usado para verificar qual o modelo com maior valor preditivo negativo.
  
  #loop para selecionar o melhor algoritmo
  while(i <= length((modelos))) {
    
    # Fit model
    model <- train(
    FALTA ~ ., #variável de desfecho
    data = train_prep, #banco de treino
    preProcess = c("center", "scale"),
    metric = "ROC", # métrica para comparação dos modelos
    method = modelos[index], #lista com indice (retorna uma string com o nome do método para cada modelo)
    trControl = myControl #aplica o controle
    
    )
    
    #fazendo a matriz de confusão para o banco de treino    
    banco_model <- model$trainingData

    banco_model$.outcome <- as.factor(banco_model$.outcome)

    cm_t <- confusionMatrix(banco_model$.outcome, sample(banco_model$.outcome))
    

    # Print model to console
    model
    
    # Print maximum ROC statistic
    max(model[["results"]][["ROC"]])
    
    #predição dos modelos no banco test_prep (que não possui a variável de desfecho - FALTA)
    predictions <- predict(model, test_prep)
    #o test_control é usado para comparação com os valores da predição, gerando a matriz de confusão.
    cm <- confusionMatrix(predictions, test_control$FALTA)
    
    #extraindo os resultados da matriz de confusão
    b <- cm$byClass %>% as.list()

    #extraindo o valor preditivo negativo da lista
    neg_pred <- b[4] %>% as.data.frame()
    neg_pred <- neg_pred$Neg.Pred.Value
    
    #verificação do maior valor preditivo negativo, como inicialmente o maior valor está atribuído como 0, o primeiro modelo sempre terá     o maior valor, ou seja, sempre que um modelo conseguir alcançar um valor preditivo negativo maior que o armazenado na memória, este      passa a ser o instrumento de verificação.
    if(neg_pred > maior_valor){
      maior_valor <- neg_pred #valor preditivo negativo passa a ser o maior valor
      resultado <- paste("O melhor modelo foi: ", modelos[index], ", com o valor preditio negativo: ", neg_pred) #mensagem para informar       o modelo com melhor resultado
      cm <- cm #cm armazena os dados da matriz de confusão (teste) do melhor modelo
      cm_t <- cm_t #cm_t armazena os dados da matriz de confusão (treino) do melhor modelo
    }
    else{
      maior_valor <- maior_valor #caso a verificação falhe, o maior_valor continua sendo ele mesmo ("atual")
    }
    
    #atualiza o indice para o i (while), e index (lista de modelos)
    i <- i + 1
    index <- index + 1
    
  }
    #desenha a matriz de confusão para o cm armazenado com o melhor modelo
    cm_p <- draw_confusion_matrix(cm)  
  
  #retorno da função (matriz de confusão de treino (cm_t), mensagem de resultado (resultado), desenho da matriz de confusão de teste       (cm_p))
  return(list(cm_t, resultado, cm_p))
  
}


```


```{r}
'
# Parallel Processing
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
'
```


#Aplicação da função
A função foi aplicada nos três bancos, retornando o resultados da matriz de confusão para treino, o modelo com melhor resultado de valor preditivo negativo e um plot da matriz de confusão para a predição no teste.
Para o banco: Odonto_Endodontia. Os resultados foram:
```{r}
'
ml_models(Odonto_Endodontia)
'
```

Para o banco: Odonto_Radiologica. Os resultados foram:
```{r}
'
ml_models(Odonto_Radiologica)
'
```

Para o banco: Odonto_Perio. Os resultados foram:
```{r}
'
ml_models(Odonto_Perio)
'
```


```{r}
'
# stop Parallel Processing
stopCluster(cl)
'
```

